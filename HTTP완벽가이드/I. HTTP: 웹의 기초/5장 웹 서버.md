# 5장. 웹 서버

## 5.1 다채로운 웹 서버

웹 서버는 HTTP 요청을 처리하고 응답을 제공하는 소프트웨어로, 다양한 형태와 규모로 존재합니다.

### 웹 서버의 종류
- **범용 소프트웨어 웹 서버**: Apache, Nginx, IIS 등 표준 컴퓨터에서 실행되는 소프트웨어
- **임베디드 웹 서버**: 프린터, 가전제품 등에 내장된 작은 웹 서버
- **웹 서버 어플라이언스**: 웹 서버 소프트웨어가 사전 설치된 전용 하드웨어

### 웹 서버의 구현
- 최소한의 기능만 제공하는 간단한 서버부터 복잡한 기능을 갖춘 대규모 서버까지 다양
- 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아 콘텐츠를 클라이언트에게 돌려주는 기본 기능 수행

## 5.2 간단한 펄 웹 서버

### 구현의 핵심 요소
- 소켓 프로그래밍을 통한 네트워크 통신
- HTTP 프로토콜 파싱
- 파일 시스템 접근
- 응답 메시지 포맷팅

## 5.3 진짜 웹 서버가 하는 일

실제 웹 서버는 기본 기능 외에도 다음과 같은 복잡한 작업들을 수행

### 주요 처리 단계
1. **커넥션 관리**: 클라이언트 연결 수락 및 관리
2. **요청 처리**: HTTP 요청 메시지 파싱 및 검증
3. **리소스 접근**: 요청된 리소스 찾기 및 접근 제어
4. **응답 생성**: 적절한 HTTP 응답 메시지 구성
5. **로깅**: 트랜잭션 정보 기록

### 추가 기능
- 가상 호스팅 지원
- 접근 제어 및 인증
- 동적 콘텐츠 생성
- 성능 최적화

## 5.4 단계 1: 클라이언트 커넥션 수락

### 새 커넥션 처리
웹 서버는 TCP 커넥션을 통해 클라이언트와 통신합니다.

#### 커넥션 수락 과정
1. **소켓 생성**: 서버는 특정 포트(보통 80)에서 리스닝 소켓 생성
2. **커넥션 대기**: 클라이언트의 연결 요청 대기
3. **커넥션 수락**: 새로운 TCP 커넥션 설정
4. **데이터 교환**: HTTP 메시지 송수신

### 클라이언트 호스트명 식별
- **역방향 DNS**: 클라이언트 IP 주소를 호스트명으로 변환
- 성능 고려사항: DNS 조회는 지연을 유발할 수 있음
- 설정 옵션: HostnameLookups 지시어로 제어

### ident를 통한 클라이언트 사용자 확인
- RFC 931에 정의된 IDENT 프로토콜 사용
- 113번 포트를 통해 클라이언트 사용자 정보 조회
- 보안 및 프라이버시 문제로 현재는 거의 사용되지 않음

## 5.5 단계 2: 요청 메시지 수신

### 요청 메시지 파싱
웹 서버는 네트워크 커넥션에서 데이터를 읽고 HTTP 요청 메시지를 파싱

#### 파싱 과정
1. **요청줄 파싱**: 메서드, URI, HTTP 버전 추출
2. **헤더 파싱**: 각 헤더 필드와 값 추출
3. **본문 읽기**: Content-Length가 있는 경우 메시지 본문 읽기

### 메시지 처리 주의사항
- **불완전한 메시지**: 네트워크 지연으로 메시지가 조각나서 도착할 수 있음
- **메시지 크기 제한**: 악의적인 요청 방지를 위한 크기 제한 필요
- **타임아웃 처리**: 느린 클라이언트 처리를 위한 타임아웃 설정

### 커넥션 입력/출력 처리 아키텍처

#### 단일 스레드 웹 서버
- 한 번에 하나의 요청만 처리
- 구현이 간단하지만 성능 제약 존재

#### 멀티프로세스와 멀티스레드 웹 서버
- 동시에 여러 요청 처리 가능
- 프로세스/스레드 생성 오버헤드 고려 필요
- 최대 프로세스/스레드 수 제한 설정

#### 다중 I/O 서버
- 모든 커넥션을 동시에 모니터링
- select(), poll(), epoll() 등 시스템 콜 활용
- 높은 동시성 지원

#### 다중 I/O와 다중 스레드 결합
- 멀티 CPU 활용과 다중 I/O의 장점 결합
- 현대적인 고성능 웹 서버의 일반적 구조

## 5.6 단계 3: 요청 처리

### 요청 메서드 처리
웹 서버는 다양한 HTTP 메서드를 지원

- **GET**: 리소스 조회
- **HEAD**: 헤더만 조회
- **POST**: 데이터 전송
- **PUT**: 리소스 생성/수정
- **DELETE**: 리소스 삭제
- **TRACE**: 요청 추적
- **OPTIONS**: 지원 메서드 확인

### 요청 검증
- URI 유효성 검사
- 필수 헤더 확인
- 버전 호환성 체크

## 5.7 단계 4: 리소스의 매핑과 접근

### Docroot (문서 루트)
웹 서버는 문서 루트를 통해 파일 시스템의 특정 디렉토리를 웹 콘텐츠의 기준점으로 사용

```
예시:
Docroot: /var/www/html
요청 URI: /index.html
실제 경로: /var/www/html/index.html
```

### 가상 호스팅된 docroot
하나의 웹 서버에서 여러 웹사이트를 호스팅하는 기능

- **IP 기반 가상 호스팅**: 각 사이트에 고유 IP 할당
- **이름 기반 가상 호스팅**: Host 헤더를 통해 사이트 구분

### 사용자 홈 디렉토리 docroot
- URL 경로: `/~username/`
- 실제 경로: 사용자의 홈 디렉토리 내 public_html 폴더
- 개인 웹 페이지 호스팅에 사용

### 디렉토리 목록
디렉토리 요청 시 처리 방법:
1. 인덱스 파일 반환 (index.html 등)
2. 디렉토리 목록 생성 (설정에 따라)
3. 오류 반환

### 동적 콘텐츠 리소스 매핑
- **CGI (Common Gateway Interface)**: 외부 프로그램 실행
- **서버 사이드 스크립트**: PHP, ASP, JSP 등
- **애플리케이션 서버 인터페이스**: FastCGI, mod_python 등

### 서버사이드 인클루드 (SSI)
HTML 파일 내에 동적 콘텐츠를 포함시키는 기능:
```html
<!--#include virtual="/header.html" -->
<!--#echo var="DATE_LOCAL" -->
```

### 접근 제어
웹 서버는 리소스에 대한 접근을 제어
- IP 주소 기반 제한
- 사용자 인증 요구
- 디렉토리별 접근 규칙 설정

## 5.8 단계 5: 응답 만들기

### 응답 엔터티
응답 메시지는 다음 요소들을 포함합니다:
- **응답 본문**: 실제 콘텐츠
- **Content-Type**: MIME 타입 지정
- **Content-Length**: 본문 크기
- **기타 엔터티 헤더**: Last-Modified, ETag 등

### MIME 타입 결정
웹 서버는 다음 방법으로 콘텐츠의 MIME 타입을 결정

1. **파일 확장자 매핑**
   ```
   .html → text/html
   .jpg → image/jpeg
   .pdf → application/pdf
   ```

2. **매직 타이핑**: 파일 내용 분석을 통한 타입 추론

3. **명시적 타이핑**: 특정 파일/디렉토리에 타입 강제 지정

4. **협상된 타입**: 콘텐츠 협상을 통한 최적 타입 선택

### 리다이렉션
웹 서버는 다음과 같은 경우 리다이렉션 응답

- **영구 이동 (301)**: 리소스가 영구적으로 이동
- **임시 이동 (302, 307)**: 리소스가 임시로 다른 위치에 있음
- **See Other (303)**: POST 후 GET 리다이렉션
- **Not Modified (304)**: 캐시된 버전 사용 가능

리다이렉션 설정 
```
/old-page → /new-page (301)
/directory → /directory/ (301)
```

## 5.9 단계 6: 응답 보내기

### 응답 전송 과정
웹 서버는 생성된 응답을 클라이언트에게 효율적으로 전송해야 합니다.

### 커넥션 관리
- **지속 커넥션**: Keep-Alive를 통한 커넥션 재사용
- **비지속 커넥션**: 응답 후 즉시 커넥션 종료
- **파이프라이닝**: 여러 요청을 동시에 처리

### 전송 최적화
- 작은 데이터는 버퍼링 후 한 번에 전송
- 큰 파일은 청크 단위로 스트리밍
- TCP_NODELAY 옵션으로 지연 최소화

## 5.10 단계 7: 로깅

### 로그의 목적
웹 서버는 트랜잭션 처리 후 다음 정보를 로그에 기록합니다:
- 트래픽 분석
- 보안 감사
- 오류 디버깅
- 사용 통계

### 로그 포맷

#### Common Log Format (CLF)
```
127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] "GET /apache_pb.gif HTTP/1.0" 200 2326
```

구성 요소:
- 클라이언트 IP
- RFC 931 사용자 (보통 -)
- 인증된 사용자명
- 요청 시간
- 요청 라인
- HTTP 상태 코드
- 응답 크기

#### Combined Log Format
CLF에 추가 정보 포함:
```
127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] "GET /apache_pb.gif HTTP/1.0" 200 2326 "http://www.example.com/start.html" "Mozilla/4.08 [en] (Win98; I ;Nav)"
```

추가 필드:
- Referer 헤더
- User-Agent 헤더

### 로그 관리
- **로그 로테이션**: 일정 크기/기간마다 새 파일 생성
- **로그 압축**: 오래된 로그 압축 보관
- **로그 분석 도구**: AWStats, Webalizer 등

## 5.11 추가 정보

### 참고 자료
- Apache HTTP Server Documentation
- Nginx Documentation
- RFC 2616 (HTTP/1.1)
- "Web Server Technology" by Nancy J. Yeager

### 관련 도구
- **벤치마킹 도구**: ab (Apache Bench), JMeter
- **모니터링 도구**: Nagios, Zabbix
- **로그 분석**: ELK Stack (Elasticsearch, Logstash, Kibana)

### 성능 튜닝 고려사항
- Worker 프로세스/스레드 수 최적화
- 캐시 설정 조정
- 압축 활성화
- 정적 콘텐츠 최적화
- CDN 활용

---

# 프론트엔드 개발자를 위한 추가 내용: 웹 서버

> 📌 **Note**: 이 섹션은 HTTP 완벽가이드 원서에는 없는 내용으로, 프론트엔드 개발자를 위해 추가로 작성된 내용입니다.

## 프론트엔드 개발자 관점의 웹 서버

### 개발 서버 vs 프로덕션 서버

#### 개발 서버 특징
프론트엔드 개발 시 사용하는 웹 서버는 프로덕션과 다른 목적을 가집니다:

- **Hot Module Replacement (HMR)**: 코드 변경 시 즉시 반영
- **Source Map 제공**: 디버깅을 위한 원본 코드 매핑
- **개발 도구 통합**: Vue DevTools, React DevTools 등
- **CORS 프록시**: API 개발 중 CORS 문제 해결

#### Vite Dev Server
Vite는 ES 모듈을 활용한 빠른 개발 서버를 제공합니다:

```javascript
// vite.config.js
export default {
  server: {
    port: 3000,
    host: 'localhost',
    open: true, // 브라우저 자동 열기
    cors: true,
    
    // HMR 설정
    hmr: {
      overlay: true,
      protocol: 'ws',
      host: 'localhost'
    }
  }
}
```

**Vite 서버의 동작 원리:**
1. **No-Bundle 방식**: 개발 중 번들링하지 않고 ES 모듈로 직접 제공
2. **의존성 사전 번들링**: node_modules는 esbuild로 사전 번들링
3. **요청 시 변환**: 브라우저 요청 시 실시간으로 TypeScript, JSX 변환
4. **효율적인 캐싱**: HTTP 헤더를 통한 강력한 캐싱

#### Webpack Dev Server
전통적인 번들링 기반 개발 서버:

```javascript
// webpack.config.js
module.exports = {
  devServer: {
    port: 8080,
    hot: true, // HMR 활성화
    liveReload: true,
    compress: true, // gzip 압축
    
    // 웹소켓을 통한 HMR 통신
    webSocketServer: 'ws',
    
    // History API Fallback (SPA 라우팅)
    historyApiFallback: true,
    
    // 정적 파일 서빙
    static: {
      directory: path.join(__dirname, 'public'),
      publicPath: '/assets/'
    }
  }
}
```

### 정적 파일 서빙 전략

#### 해시 기반 캐싱
빌드 시 파일명에 해시를 추가하여 캐시 무효화:

```javascript
// vite.config.js
export default {
  build: {
    rollupOptions: {
      output: {
        entryFileNames: 'assets/[name].[hash].js',
        chunkFileNames: 'assets/[name].[hash].js',
        assetFileNames: 'assets/[name].[hash].[ext]'
      }
    }
  }
}
```

서버 설정 (Nginx):
```nginx
location /assets/ {
    expires 1y;  # 1년 캐싱
    add_header Cache-Control "public, immutable";
}

location / {
    add_header Cache-Control "no-cache";  # HTML은 항상 최신
}
```

#### Compression (압축)
프론트엔드 애셋 압축 전략:

```javascript
// vite.config.js - 빌드 시 압축
import viteCompression from 'vite-plugin-compression';

export default {
  plugins: [
    viteCompression({
      algorithm: 'gzip',
      ext: '.gz',
    }),
    viteCompression({
      algorithm: 'brotliCompress',
      ext: '.br',
    })
  ]
}
```

Nginx에서 사전 압축 파일 서빙:
```nginx
location ~* \.(js|css|html)$ {
    gzip_static on;  # .gz 파일 우선 제공
    brotli_static on;  # .br 파일 우선 제공
}
```

### HTTP/2와 모던 웹 애플리케이션

#### HTTP/2 Server Push
초기 로딩 최적화:

```nginx
location /index.html {
    http2_push /css/main.css;
    http2_push /js/app.js;
    http2_push /fonts/main.woff2;
}
```

Link 헤더를 통한 푸시:
```html
Link: </css/main.css>; rel=preload; as=style
Link: </js/app.js>; rel=preload; as=script
```

#### 멀티플렉싱 활용
HTTP/2의 스트림 멀티플렉싱으로 번들 분할 전략 변화:

```javascript
// vite.config.js - 세밀한 코드 분할
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor': ['vue', 'vue-router', 'pinia'],
          'ui': ['element-plus'],
          'utils': ['lodash', 'axios']
        }
      }
    }
  }
}
```

### Service Worker와 웹 서버 협력

#### Cache-First 전략
Service Worker와 웹 서버 캐시 헤더 조합:

```javascript
// service-worker.js
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(response => {
      // Cache hit - return response
      if (response) {
        return response;
      }
      
      return fetch(event.request).then(response => {
        // Check if valid response
        if (!response || response.status !== 200) {
          return response;
        }
        
        // Clone and cache
        const responseToCache = response.clone();
        caches.open('v1').then(cache => {
          cache.put(event.request, responseToCache);
        });
        
        return response;
      });
    })
  );
});
```

서버 측 캐시 제어:
```nginx
# Service Worker 파일은 캐시하지 않음
location /service-worker.js {
    add_header Cache-Control "no-cache";
}

# 정적 애셋은 장기 캐싱
location /static/ {
    add_header Cache-Control "public, max-age=31536000";
}
```

### CORS 설정

#### 개발 환경 CORS
프론트엔드 개발 시 CORS 문제 해결:

```nginx
# API 서버 CORS 설정
location /api/ {
    add_header Access-Control-Allow-Origin $http_origin always;
    add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
    add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;
    add_header Access-Control-Allow-Credentials true always;
    
    if ($request_method = OPTIONS) {
        return 204;
    }
}
```

#### 프로덕션 CORS 보안
```nginx
map $http_origin $cors_origin {
    default "";
    "https://app.example.com" $http_origin;
    "https://www.example.com" $http_origin;
}

location /api/ {
    add_header Access-Control-Allow-Origin $cors_origin always;
}
```

### CSP (Content Security Policy)

프론트엔드 보안을 위한 CSP 헤더 설정:

```nginx
add_header Content-Security-Policy "
    default-src 'self';
    script-src 'self' 'unsafe-inline' https://cdn.example.com;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    font-src 'self' https://fonts.gstatic.com;
    img-src 'self' data: https:;
    connect-src 'self' https://api.example.com wss://ws.example.com;
" always;
```

